#!/usr/bin/ruby

USAGE = "rdpipe HOST:CMD ..."

if ARGV.length < 1
	STDERR.puts(USAGE)
	exit!(1)
end

$dryrun = false
if ARGV.delete("-n")
	$dryrun = true
end

verbose = ""
if ARGV.delete("-v")
	verbose = "-v"
end

dir = File.dirname(__FILE__)

recvport = "7692"
sendport = "7691"
localhost = `hostname`.strip

key = rand.to_s

# rdsend tries to open a connection until the other side has a port open or timeout happens.
#

hostcmds = ARGV.map {|arg| arg.split(":", 2) }
hosts = hostcmds.map{|hc| hc[0] }
hosts.push(localhost)

host_idx = 1
no_input = $stdin.isatty
no_output = $stdin.isatty
sshcmds = []
hostcmds.each_with_index do |(host,cmd), idx|
	nexthost = hosts[host_idx]
	host_idx += 1

	sshcmdprefix = if no_input 
		"#{dir}/rdrecv #{verbose} #{sendport} #{key} >/dev/null; "
	else
		"#{dir}/rdrecv #{verbose} #{sendport} #{key} "
	end

	if cmd =~ /^</ # source from file, cancel output of the previous segment if it has some
		if not no_input and idx == 0
			no_output = true
		end
		sshcmdsuffix = "#{no_input ? "" : ">/dev/null; "}#{dir}/rdsend #{verbose} #{nexthost} #{sendport} #{key} #{cmd}"
		no_input = false

	elsif cmd =~ /^>/ # write to file, no stdout. In case there's no input, just create an empty file.
		sshcmdsuffix = if no_input
			if cmd =~ /^>>/
				"touch -- #{cmd[2..-1]}; #{dir}/rdsend #{verbose} #{nexthost} #{sendport} #{key}"
			else
				"truncate -s 0 -- #{cmd[1..-1]}; #{dir}/rdsend #{verbose} #{nexthost} #{sendport} #{key}"
			end
		else
			"#{cmd}; #{dir}/rdsend #{verbose} #{nexthost} #{sendport} #{key}"
		end
		no_input = true

	else 
		# If there's input, pipe it to the command, otherwise just run the command.
		sshcmdsuffix = "#{no_input ? "" : "| "}(#{cmd}) | #{dir}/rdsend #{verbose} #{nexthost} #{sendport} #{key}"
		no_input = false
	end

	sshcmd = sshcmdprefix + sshcmdsuffix

	sshcmds << [host, sshcmd]
end


def spawn(*args, opts)
	if $dryrun
		p(args)
	else
		Process.spawn(*args, opts)
	end
end


#if not no_input
	recvpid = spawn("#{dir}/rdrecv", sendport, key, :in => :close, :err => :err, :out => :out)
#end

remotepids = sshcmds.reverse.map do |(host,cmd)| 
	spawn("ssh", host, cmd, :in => :close, :err => :err, :out => :close)
end

#if not no_output
	if verbose != ""
		sendpid = spawn("#{dir}/rdsend", verbose, hosts[0], sendport, key, :in => $stdin.isatty ? :close : :in, :err => :err, :out => :close)
	else
		sendpid = spawn("#{dir}/rdsend", hosts[0], sendport, key, :in => $stdin.isatty ? :close : :in, :err => :err, :out => :close)
	end
#end

Process.waitall()
